# MM113: NumberCreator

#### provisional  

standing: 17th / 45  
score: 71.77046

## 概要

* 三桁以下の数字 num0, num1 が与えられる
* (整数の)四則演算を用いてクソでかい数 T を生成する
* T は 4 桁から 100 桁までの数
* T は各桁の数字をランダムに選んで生成される

## 垂れ流し

### submission 1

自明解の作成

1 を作れれば 2 べきが順次生成できる  
T を 2 進数にしたときの桁数を d として、2^(d-1) まで生成して  
立っているビットを全部足し合わせれば OK

FA をとった　よかった

### submission 2

以降 T は 2 進数で表す  
T = 10001000 のとき、必要なのは 2^4, 2^8 のみ  
submission 1 では 2 べきを全て生成していたが、ダブリングの要領で 1->2->4->8 とすれば短縮になる

ローカルで 45% 程度向上

### submission 3

yowa さんと三倍近い差が開いていたのでちゃんと考える

T = 111000001100011111000

のとき、

111 * 10000000 = 1110000000  
1110000000 + 11 = 1110000011  
1110000011 * 100000000 = 111000001100000000  
111000001100000000 + 11111 = 111000001100011111  
111000001100011111 * 1000 = 111000001100011111000 = T

2 べき (exp2) と 111... (rep1) を用意しておけば、ランレングスっぽい感じで計算回数を短縮できる

submission 2 と比べてローカルで 65% 程度向上

### submission 4

リファクタリング  
exp2 と rep1 を前計算でなく modpow の要領で再帰計算する (seed1 で score 41->9 になった)

submission 3 と比べて ローカルで 3.6% 程度向上

### submission 5

yowa さんと二倍近い差が開いているので考える

必要な exp2 と rep1 は全て揃っているとする

1000 = exp2(3)  
11111 = rep1(5)  
のように表記する

T = 11100011110111 として、  
T = (rep1(3) * exp2(7) + rep1(4)) * exp2(5) + rep1(3) で演算 4 回  
T = rep1(3) * exp2(11) + rep1(8) - exp2(4) で演算 3 回

また、  
T = 1100000100011 として、  
T = (rep1(2) * exp2(6) + rep1(1)) * exp2(5) + rep1(2) で演算 4 回  
T = (rep1(2) * exp2(11) + exp2(5) + rep1(2) で演算 3 回

つまり、1 や 0 が連続している区間で一つだけ異なる要素がある場合、計算回数を減らす余地がある

10000111101101111 などは (exp2 と rep1 が全て揃っている前提で) 演算を 2 回減らせる

exp2, rep1 生成コストの兼ね合いもあり、どこまで短縮するかの場合分けが生じる  
→ ビームサーチを使ってみよう

```
0...0 1...1 0     1...1 0     1...1 0...0 型
ptr0  ptr1  ptr2  ptr3  ptr4  ptr5  end

0...0 1     0...0 1     0...0 1...1 0...0 型
ptr0  ptr1  ptr2  ptr3  ptr4  ptr5  end
```

submission 4 と比べて ローカルで 20% 程度向上

順位表では 66.45689 点

何かもっと賢い方法がありそう


---

なんもわからん

とりあえず遊んでみる

```
seed 3

0:      788
1:      649
2:      1
3:      2
4:      4
5:      6
6:      10
7:      100
8:      1000
9:      10000
10:     7
11:     42
12:     5
13:     5000
14:     5042
15:     50420000
16:     9
17:     36
18:     136
19:     1136
20:     50421136
21:     1001
22:     4004
23:     504211360000
24:     504211364004
25:     5042113640040000
26:     70
27:     71
28:     929
29:     929000
30:     929001
31:     504211364004000000
32:     504211364004929001
33:     50
34:     25
35:     84
36:     8400
37:     8425
38:     5042113640049290010000
39:     5042113640049290018425
40:     9290
41:     9296
42:     50421136400492900184250000
43:     50421136400492900184259296
44:     23
45:     2300
46:     2310
47:     504211364004929001842592960000
48:     504211364004929001842592962310
49:     26
50:     200
51:     5200
52:     5271
53:     5042113640049290018425929623100000
54:     5042113640049290018425929623105271
55:     77
56:     7700
57:     50421136400492900184259296231052710000
58:     50421136400492900184259296231052717700
59:     500
60:     5542
61:     5540
62:     504211364004929001842592962310527177000000
63:     504211364004929001842592962310527177005540
64:     6564
65:     90
66:     6654
67:     5042113640049290018425929623105271770055400000
68:     5042113640049290018425929623105271770055406654
69:     5204
70:     50421136400492900184259296231052717700554066540000
71:     50421136400492900184259296231052717700554066545204
72:     4212
73:     19
74:     4231
75:     504211364004929001842592962310527177005540665452040000
76:     504211364004929001842592962310527177005540665452044231

steps: 75
```

現行解法が 87 ステップ掛かっているので、手でやったほうが優秀  
なんとなく何をすればいいかわかったような気がする

たとえば、10 進数で 4 桁区切りにした数字 (targetSet とする)

5042 1136 4004 9290 0184 2592 9623 1052 7177 0055 4066 5452 0442 31

を作ることを目指す

2 ターン、3 ターン先まで読んで、生成された整数に targetSet の要素 (と、それに近いもの) が含まれているなら得点を与える

整数を作る際、巨大な数に add するのではなく、4 桁の数を生成してから足すと次の状態に繋げやすい

10000 を作るまでの過程はまずは定跡としてしまう

---

### submission 6

ランレングスビームサーチを BinarySolver、上で書いたやつを適当に実装したものを DecimalSolver として、2 つのいい方を採用

ローカルで 31% 程度向上

順位表では 72 点くらいになった

---

無限に -1 が帰ってきたので地獄デバッグをしていた(Java 提出において日本語コメントがあると死ぬ？)

探索系の実装が下手すぎるため、適当を実装した時点で honesty and good sportsmanship により撤退

探索を枝刈り dfs っぽくすればもっと良いスコアが出た気がする